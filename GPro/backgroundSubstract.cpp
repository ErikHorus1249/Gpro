#define _CRT_SECURE_NO_DEPRECATE
//opencv
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/videoio.hpp"
#include <opencv2/highgui.hpp>
#include <opencv2/video.hpp>
//C
#include <stdio.h>
//C++
#include <iostream>
#include <sstream>

using namespace cv;
using namespace std;

// Global variables
Mat frame; //current frame
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
char keyboard; //input from keyboard

void processVideo(char* videoFilename);
void processImages(char* firstFrameFilename);
void Threshoder(Mat matrix) {
	for (size_t i = 0; i < matrix.rows; i++)
	{
		for (size_t j = 0; j < matrix.cols; j++)
		{
			int t = (int)matrix.at<uchar>(i, j);
			if (t > 30) {
				matrix.at<uchar>(i, j) = 255;
			}
			else {
				matrix.at<uchar>(i, j) = 0;
			}
		}
	}
}

Mat redFilter(const Mat& src)
{
	//assert(src.type() == CV_8UC3);

	Mat redOnly;     //	B	G	R
	inRange(src, Scalar(51, 81, 213), Scalar(178,203,255), redOnly);

	return redOnly;
}


void backGroundSubs()
{
	//create GUI windows
	namedWindow("Frame");
	namedWindow("FG Mask MOG 2");
	//create Background Subtractor objects
	pMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach
	processVideo("E:/opencvPracticles/sample-1- France vs Brazil- 360p.mp4");
	//destroy GUI windows
	destroyAllWindows();
}
void processVideo(char* videoFilename) {
	//create the capture object
	VideoCapture capture(videoFilename);
	if (!capture.isOpened()) {
		//error in opening the video input
		cerr << "Unable to open video file: " << videoFilename << endl;
		//exit(EXIT_FAILURE);
	}
	//read input data. ESC or 'q' for quitting
	keyboard = 0;


	while (keyboard != 'q' && keyboard != 27) {
		//read the current frame
		if (!capture.read(frame)) {
			cerr << "Unable to read next frame." << endl;
			cerr << "Exiting..." << endl;
			//exit(EXIT_FAILURE);
		}
		////update the background model
		//pMOG2->apply(frame, fgMaskMOG2);
		////get the frame number and write it on the current frame
		//stringstream ss;
		//rectangle(frame,Point(10, 2), Point(100, 20),Scalar(255, 255, 255), -1);
		//
		//ss << capture.get(CAP_PROP_POS_FRAMES);
		//string frameNumberString = ss.str();
		//putText(frame, frameNumberString.c_str(), Point(15, 15), FONT_HERSHEY_SIMPLEX, 0.5, Scalar(0, 0, 0));
		//cvtColor(frame, frame, COLOR_BGR2GRAY);

		//for (size_t i = 0; i < frame.rows; i++)
		//{
		//	for (size_t j = 0; j < frame.cols; j++)
		//	{
		//		if ((int)fgMaskMOG2.at<uchar>(i, j) <= 5) {
		//			frame.at<uchar>(i, j) = 0;
		//		}
		//	}
		//}

		Mat red = redFilter(frame);
											//	B	G	R
	//	circle(frame, Point(100, 30), 3, Scalar(25, 92, 245), 1, 8, 0);

		//Threshoder(fgMaskMOG2);
		//show the current frame and the fg masks  
		imshow("Frame", frame);
		imshow("FG Mask MOG 2", red);
		//get the input from the keyboard
		keyboard = (char)waitKey(30);
	}
	//delete capture object
	capture.release();
}

